<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WCL Time Splits Analyzer</title>
    <style>
      /* Basic page setup */
      html {
        /* Always show scrollbar to prevent layout shifts when content overflows */
        overflow-y: scroll;
      }
      body {
        font-family: sans-serif;
        background-color: #2c2f33;
        color: #f0f0f0;
        margin: 20px;
      }

      /* Main form styling */
      .form-card {
        background-color: #40444b;
        padding: 40px;
        border-radius: 8px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        text-align: center;
        max-width: 500px;
        margin: 40px auto;
      }
      h1 {
        color: #7289da;
        margin-bottom: 30px;
      }
      input[type="text"] {
        width: 300px;
        padding: 12px;
        margin-bottom: 20px;
        border: 1px solid #54585e;
        background-color: #36393f;
        color: #f0f0f0;
        border-radius: 4px;
      }
      button {
        background-color: #7289da;
        color: white;
        padding: 12px 24px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.2s ease-in-out;
      }
      button:hover {
        background-color: #677bc4;
      }
      .report-group {
        margin-bottom: 20px;
      }

      /* Toggle switch for showing/hiding trash fights */
      .toggle-group {
        margin: 25px 0;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 10px;
        color: #b9bbbe;
      }

      /* Loading indicator shown during API fetch */
      #loading-indicator {
        display: none;
        margin-top: 20px;
        font-size: 1.2em;
        color: #b9bbbe;
        align-items: center;
        justify-content: center;
        gap: 15px;
      }
      .spinner {
        width: 24px;
        height: 24px;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: #7289da;
        animation: spin 1s ease-in-out infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      /* Container for the result cards */
      .container {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        justify-content: center;
        margin-top: 40px;
      }
      .report-card {
        background-color: #40444b;
        border: 1px solid #54585e;
        border-radius: 8px;
        padding: 15px;
        flex: 1 1 45%;
        min-width: 400px;
        box-sizing: border-box;
      }
      .error-card {
        padding: 30px;
        color: #e74c3c;
        text-align: center;
      }
      h2 {
        color: #ffffff;
        border-bottom: 2px solid #7289da;
        padding-bottom: 5px;
        font-size: 1.5em;
        margin-top: 0;
      }
      p {
        color: #b9bbbe;
      }

      /* Table styling */
      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 15px;
        table-layout: fixed;
      }
      th,
      td {
        padding: 10px;
        text-align: left;
        border-bottom: 1px solid #54585e;
        word-wrap: break-word;
      }
      th:first-child,
      td:first-child {
        width: 30%;
      } /* Give 'Name' column more width */
      th {
        background-color: #36393f;
      }
      tr:nth-child(even) {
        background-color: #4a4e55;
      }

      /* Row-specific styling */
      .boss {
        font-weight: bold;
        border-top: 1px solid #54585e;
      }
      .wipe {
        color: #e74c3c;
        font-style: italic;
      }
      .trash {
        color: #99aab5;
      }

      /* Delta time colors for comparison */
      .delta-positive {
        color: #e74c3c;
        font-weight: bold;
      } /* Red for slower */
      .delta-negative {
        color: #2ecc71;
        font-weight: bold;
      } /* Green for faster */
      
      /* Highlight significant deltas */
      .delta-significant {
        background-color: rgba(231, 76, 60, 0.1);
        padding: 2px 4px;
        border-radius: 3px;
      }
      .delta-significant.delta-negative {
        background-color: rgba(46, 204, 113, 0.1);
      }

      .summary-row {
        font-weight: bold;
        background-color: #36393f;
      }
      .total-runtime span {
        font-size: 1.1em;
        font-weight: bold;
      }

      /* "Back to Top" button styling */
      #back-to-top {
        display: none;
        position: fixed;
        bottom: 30px;
        right: 30px;
        z-index: 99;
        border: none;
        outline: none;
        background-color: #7289da;
        color: white;
        cursor: pointer;
        padding: 15px;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        font-size: 18px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }
      #back-to-top:hover {
        background-color: #677bc4;
      }

      /* Responsive design for smaller screens */
      @media (max-width: 800px) {
        .report-card {
          flex-basis: 100%;
          min-width: 0;
        }
        th,
        td {
          padding: 8px 3px;
          font-size: 0.8em;
          white-space: normal;
        }
        th:first-child,
        td:first-child {
          width: 25%;
        } /* Adjust name column width for mobile */
        h1 {
          font-size: 1.5em;
        }
        h2 {
          font-size: 1.2em;
        }
        #back-to-top {
          bottom: 20px;
          right: 20px;
          width: 40px;
          height: 40px;
          font-size: 14px;
        }
      }
    </style>
  </head>
  <body>
    <div id="top-anchor"></div>

    <div class="form-card">
      <h1>WCL Time Splits Analyzer</h1>
      <form id="report-form">
        <div class="report-group">
          <label for="report_id1">Report ID 1:</label><br />
          <input type="text" id="report_id1" name="report_id1" required 
                 placeholder="e.g., xkTQz4GyjJ6XFbhw or full URL" />
          <small style="display: block; color: #99aab5; margin-top: 5px;">
            Enter report ID or paste full WarcraftLogs URL
          </small>
        </div>
        <div class="report-group">
          <label for="report_id2">Report ID 2 (Optional for comparison):</label><br />
          <input type="text" id="report_id2" name="report_id2" 
                 placeholder="e.g., WqaDLpJjXzM9ymfK or full URL" />
          <small style="display: block; color: #99aab5; margin-top: 5px;">
            Enter second report for side-by-side comparison
          </small>
        </div>
        <div class="toggle-group">
          <input type="checkbox" id="show-trash" name="show-trash" checked />
          <label for="show-trash">Show Trash Fights</label>
        </div>
        <button type="submit">Analyze</button>
      </form>
      <div id="loading-indicator">
        <div class="spinner"></div>
        <span>Fetching and processing logs...</span>
      </div>
    </div>

    <div id="results-container" class="container"></div>

    <a href="#top-anchor"><button id="back-to-top">▲</button></a>

    <script>
      // Global state to hold the most recently fetched report data
      let currentReportData = null;

      /**
       * Formats a duration in milliseconds to a human-readable string (H:MM:SS or MM:SS).
       * @param {number} ms - The duration in milliseconds.
       * @param {boolean} [includeHours=true] - Whether to include the hours part.
       * @returns {string} The formatted timestamp or '---' on invalid input.
       */
      function formatTimestamp(ms, includeHours = true) {
        if (typeof ms !== "number") return "---";
        const sign = ms < 0 ? "-" : "";
        const totalSeconds = Math.round(Math.abs(ms) / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        const paddedMinutes = String(minutes).padStart(2, "0");
        const paddedSeconds = String(seconds).padStart(2, "0");

        if (includeHours) {
          return `${sign}${hours}:${paddedMinutes}:${paddedSeconds}`;
        } else {
          return `${sign}${paddedMinutes}:${paddedSeconds}`;
        }
      }

      // DOM element references
      const form = document.getElementById("report-form");
      const loadingIndicator = document.getElementById("loading-indicator");
      const resultsContainer = document.getElementById("results-container");
      const showTrashToggle = document.getElementById("show-trash");
      const backToTopButton = document.getElementById("back-to-top");

      // Event listener to show/hide the "Back to Top" button based on scroll position
      window.onscroll = function () {
        if (
          document.body.scrollTop > 100 ||
          document.documentElement.scrollTop > 100
        ) {
          backToTopButton.style.display = "block";
        } else {
          backToTopButton.style.display = "none";
        }
      };

      /**
       * Extracts report ID from a WarcraftLogs URL or returns the input if it's already an ID
       * @param {string} input - URL or report ID
       * @returns {string} - Extracted report ID
       */
      function extractReportId(input) {
        if (!input) return "";
        
        // Check if it's already a report ID (alphanumeric, typically 16 characters)
        if (/^[a-zA-Z0-9]{10,20}$/.test(input.trim())) {
          return input.trim();
        }
        
        // Extract from URL patterns like:
        // https://classic.warcraftlogs.com/reports/xkTQz4GyjJ6XFbhw
        // https://fresh.warcraftlogs.com/reports/WqaDLpJjXzM9ymfK
        const urlMatch = input.match(/\/reports\/([a-zA-Z0-9]+)/);
        if (urlMatch) {
          return urlMatch[1];
        }
        
        // If no pattern matches, return the input as-is
        return input.trim();
      }

      // Main event listener for form submission
      form.addEventListener("submit", function (event) {
        event.preventDefault(); // Prevent default form submission
        loadingIndicator.style.display = "flex";
        resultsContainer.innerHTML = ""; // Clear previous results
        
        // Extract report IDs from URLs if needed
        const reportId1 = extractReportId(document.getElementById("report_id1").value);
        const reportId2 = extractReportId(document.getElementById("report_id2").value);
        
        // Create form data with extracted IDs
        const formData = new FormData();
        formData.append("report_id1", reportId1);
        if (reportId2) {
          formData.append("report_id2", reportId2);
        }

        // Use the Fetch API to send data to the backend
        fetch("/report", { method: "POST", body: formData })
          .then((response) => {
            if (!response.ok) {
              throw new Error("Network response was not ok");
            }
            return response.json();
          })
          .then((data) => {
            loadingIndicator.style.display = "none";
            currentReportData = data; // Store the fetched data globally
            renderResults(); // Render the new data
          })
          .catch((error) => {
            loadingIndicator.style.display = "none";
            resultsContainer.innerHTML = `<p class="report-card error-card">Error: ${error.message}. Please check the report IDs and try again.</p>`;
            console.error(
              "There was a problem with the fetch operation:",
              error
            );
          });
      });

      // Event listener for the "Show Trash" toggle to re-render the data without a new fetch
      showTrashToggle.addEventListener("change", () => {
        if (currentReportData) {
          renderResults();
        }
      });

      /**
       * Main rendering function. Filters data based on the "Show Trash" toggle
       * and calls buildReportCard to generate the HTML.
       */
      function renderResults() {
        if (!currentReportData) return;

        let html = "";
        const { data1, data2 } = currentReportData;
        const showTrash = showTrashToggle.checked;

        // Filter out trash fights if the toggle is unchecked
        const filteredData1 =
          data1 && !data1.error
            ? {
                ...data1,
                fights: showTrash
                  ? data1.fights
                  : data1.fights.filter((f) => f.is_boss),
              }
            : data1;
        const filteredData2 =
          data2 && !data2.error
            ? {
                ...data2,
                fights: showTrash
                  ? data2.fights
                  : data2.fights.filter((f) => f.is_boss),
              }
            : data2;

        // Create a lookup map of boss kill times from the second report for comparison
        let report2BossEndTimes = {};
        if (data2 && !data2.error) {
          report2BossEndTimes = Object.fromEntries(
            data2.fights
              .filter((f) => f.is_boss)
              .map((f) => [f.name, Math.round(f.end_time_rel / 1000)])
          );
        }

        if (filteredData1) {
          html += buildReportCard(
            filteredData1,
            filteredData2,
            report2BossEndTimes
          );
        }
        if (filteredData2) {
          html += buildReportCard(filteredData2, null, null);
        } // Render second card without comparison data
        resultsContainer.innerHTML = html;
      }

      /**
       * Builds the HTML for a single report card.
       * @param {object} reportData - The processed data for the primary report.
       * @param {object|null} compareData - The data for the comparison report.
       * @param {object|null} compareTimes - A map of boss end times from the comparison report.
       * @returns {string} The generated HTML string for the report card.
       */
      function buildReportCard(reportData, compareData, compareTimes) {
        if (!reportData) return "";

        // Handle and display errors gracefully
        if (reportData.error) {
          return `<div class="report-card error-card"><h2>Processing Failed</h2><p>${reportData.error}</p></div>`;
        }

        // Check for Naxxramas-specific data to conditionally show columns
        const isNaxx = reportData.zone === "Naxxramas";
        const hasWingTimeData =
          isNaxx && reportData.fights.some((fight) => fight.wing_time !== null);
        const compareNaxx =
          compareData &&
          !compareData.error &&
          compareData.zone === "Naxxramas" &&
          hasWingTimeData;

        // Create a lookup map of wing times from the comparison report if applicable
        let compareWingTimes = {};
        if (compareNaxx) {
          compareWingTimes = Object.fromEntries(
            compareData.fights
              .filter((f) => f.wing_time !== null)
              .map((f) => [f.name, f.wing_time])
          );
        }

        let totalIdle = 0;
        // Generate each row of the table
        let tableRows = reportData.fights
          .map((fight) => {
            totalIdle += fight.idle_time;
            let deltaCell = "";
            let wingDeltaCell = "";

            // Calculate and format delta times if a comparison report is provided
            if (compareData && !compareData.error) {
              let deltaContent = "&mdash;"; // Default for non-bosses or non-matching bosses
              if (fight.is_boss && compareTimes[fight.name] !== undefined) {
                const endSeconds1 = Math.round(fight.end_time_rel / 1000);
                const endSeconds2 = compareTimes[fight.name];
                const delta = (endSeconds1 - endSeconds2) * 1000;
                const sign = delta > 0 ? "+" : "";
                const deltaClass =
                  delta > 0 ? "delta-positive" : "delta-negative";
                const arrow = delta > 0 ? "▲" : "▼";

                if (delta !== 0) {
                  deltaContent = `<span class="${deltaClass}">${arrow} ${sign}${formatTimestamp(
                    delta,
                    false
                  )}</span>`;
                } else {
                  deltaContent = `<span>${formatTimestamp(
                    delta,
                    false
                  )}</span>`;
                }
              }
              deltaCell = `<td>${deltaContent}</td>`;

              // Calculate wing time deltas if applicable
              if (compareNaxx) {
                let wingDeltaContent = "";
                if (
                  fight.wing_time &&
                  compareWingTimes[fight.name] !== undefined
                ) {
                  const wingDelta =
                    fight.wing_time - compareWingTimes[fight.name];
                  const sign = wingDelta > 0 ? "+" : "";
                  const deltaClass =
                    wingDelta > 0 ? "delta-positive" : "delta-negative";
                  const arrow = wingDelta > 0 ? "▲" : "▼";
                  wingDeltaContent = `<span class="${deltaClass}">${arrow} ${sign}${formatTimestamp(
                    wingDelta,
                    false
                  )}</span>`;
                }
                wingDeltaCell = `<td>${wingDeltaContent}</td>`;
              }
            }

            const wingTimeCell = hasWingTimeData
              ? `<td>${
                  fight.wing_time ? formatTimestamp(fight.wing_time) : ""
                }</td>`
              : "";
            const rowClass = fight.is_boss
              ? fight.is_kill
                ? "boss"
                : "boss wipe"
              : "trash";

            return `<tr class="${rowClass}">
                            <td>${fight.name}</td>
                            <td>${formatTimestamp(fight.idle_time)}</td>
                            <td>${formatTimestamp(fight.start_time_rel)}</td>
                            <td>${formatTimestamp(fight.duration)}</td>
                            <td>${formatTimestamp(fight.end_time_rel)}</td>
                            ${wingTimeCell}
                            ${deltaCell}
                            ${wingDeltaCell}
                        </tr>`;
          })
          .join("");

        // Conditionally add headers for the delta columns
        const wingHeader = hasWingTimeData ? "<th>Wing Time</th>" : "";
        const deltaHeader = compareData ? "<th>Delta</th>" : "";
        const wingDeltaHeader = compareNaxx ? "<th>Wing Delta</th>" : "";
        const summaryColspan =
          3 +
          (hasWingTimeData ? 1 : 0) +
          (compareData ? 1 : 0) +
          (compareNaxx ? 1 : 0);

        // Assemble the final HTML for the card
        return `
                <div class="report-card">
                    <h2>${reportData.title}</h2>
                    <p>${reportData.zone} - ${reportData.date}</p>
                    <table>
                        <thead>
                            <tr><th>Name</th><th>Idle</th><th>Start</th><th>Duration</th><th>End</th>${wingHeader}${deltaHeader}${wingDeltaHeader}</tr>
                        </thead>
                        <tbody>
                            ${tableRows}
                            <tr class="summary-row">
                                <td colspan="2">Total Idle Time: ${formatTimestamp(
                                  totalIdle
                                )}</td>
                                <td colspan="${summaryColspan}">
                                    Total Run Time: <span>${formatTimestamp(
                                      reportData.total_duration
                                    )}</span>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>`;
      }
    </script>
  </body>
</html>
